<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>mogptk.csm API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mogptk.csm</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import numpy as np
from .model import model
from .kernels import CrossSpectralMixture, Noise
from .sm import _estimate_from_sm

class CSM(model):
    &#34;&#34;&#34;
    Cross Spectral Mixture kernel [1] with Q components and Rq latent functions.

    Args:
        dataset (mogptk.dataset.DataSet): DataSet object of data for all channels.
        Q (int, optional): Number of components.
        Rq (int, optional): Sub components por components.
        name (str, optional): Name of the model.
        likelihood (gpflow.likelihoods, optional): Likelihood to use from GPFlow, if None a default exact inference Gaussian likelihood is used.
        variational (bool, optional): If True, use variational inference to approximate function values as Gaussian. If False it will use Monte Carlo Markov Chain.
        sparse (bool, optional): If True, will use sparse GP regression.
        like_params (dict, optional): Parameters to GPflow likelihood.

    Examples:
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; t = np.linspace(0, 10, 100)
        &gt;&gt;&gt; y1 = np.sin(0.5 * t)
        &gt;&gt;&gt; y2 = 2 * np.sin(0.2 * t)
        &gt;&gt;&gt; import mogptk
        &gt;&gt;&gt; data_list = []
        &gt;&gt;&gt; mogptk.data_list.append(mogptk.Data(t, y1))
        &gt;&gt;&gt; mogptk.data_list.append(mogptk.Data(t, y2))
        &gt;&gt;&gt; model = mogptk.CSM(data_list, Q=2)
        &gt;&gt;&gt; model.build()
        &gt;&gt;&gt; model.train()
        &gt;&gt;&gt; model.plot_prediction()

    [1] K.R. Ulrich et al, &#34;GP Kernels for Cross-Spectrum Analysis&#34;, Advances in Neural Information Processing Systems 28, 2015
    &#34;&#34;&#34;
    def __init__(self, dataset, Q=1, Rq=1, name=&#34;CSM&#34;, likelihood=None, variational=False, sparse=False, like_params={}):
        if Rq != 1:
            raise Exception(&#34;Rq != 1 is not (yet) supported&#34;) # TODO: support

        model.__init__(self, name, dataset)
        self.Q = Q
        self.Rq = Rq

        with self.graph.as_default():
            with self.session.as_default():
                for q in range(self.Q):
                    kernel = CrossSpectralMixture(
                        self.dataset.get_input_dims()[0],
                        self.dataset.get_output_dims(),
                        self.Rq,
                    )
                    if q == 0:
                        kernel_set = kernel
                    else:
                        kernel_set += kernel
                kernel_set += Noise(self.dataset.get_input_dims()[0], self.dataset.get_output_dims())
                self._build(kernel_set, likelihood, variational, sparse, like_params)
    
    def estimate_params(self, method=&#39;BNSE&#39;, sm_method=&#39;BNSE&#39;, sm_opt=&#39;BFGS&#39;, sm_maxiter=3000, plot=False):
        &#34;&#34;&#34;
        Estimate kernel parameters.

        The initialization can be done in two ways, the first by estimating the PSD via 
        BNSE (Tobar 2018) and then selecting the greater Q peaks in the estimated spectrum,
        the peaks position, magnitude and width initialize the mean, magnitude and variance
        of the kernel respectively.
        The second way is by fitting independent Gaussian process for each channel, each one
        with SM kernel, using the fitted parameters for initial values of the multioutput kernel.

        In all cases the noise is initialized with 1/30 of the variance 
        of each channel.

        Args:
            method (str, optional): Method of estimation, possible values are &#39;BNSE&#39; and &#39;SM&#39;.
            sm_method (str, optional): Method of estimating SM kernels. Only valid in &#39;SM&#39; mode.
            sm_opt (str, optional): Optimization method for SM kernels. Only valid in &#39;SM&#39; mode.
            sm_maxiter (str, optional): Maximum iteration for SM kernels. Only valid in &#39;SM&#39; mode.
            plot (bool, optional): Show the PSD of the kernel after fitting SM kernels. Only valid in &#39;SM&#39; mode.
        &#34;&#34;&#34;

        if method == &#39;BNSE&#39;:
            amplitudes, means, variances = self.dataset.get_bnse_estimation(self.Q)
            for q in range(self.Q):
                constant = np.empty((self.dataset.get_input_dims()[0], self.dataset.get_output_dims()))
                for channel in range(len(self.dataset)):
                    constant[:,channel] = amplitudes[channel][:,q].mean()
            
                constant = constant / constant.max()
                mean = np.array(means)[:,:,q].mean(axis=0)
                variance = np.array(variances)[:,:,q].mean(axis=0)

                self.set_param(q, &#39;constant&#39;, constant)
                self.set_param(q, &#39;mean&#39;, mean * 2 * np.pi)
                self.set_param(q, &#39;variance&#39;, variance * 5)
        elif method == &#39;SM&#39;:
            params = _estimate_from_sm(self.dataset, self.Q, method=sm_method, optimizer=sm_opt, maxiter=sm_maxiter, plot=plot)
            for q in range(self.Q):
                self.set_param(q, &#39;constant&#39;, params[q][&#39;weight&#39;].mean(axis=0).reshape(self.Rq, -1))
                self.set_param(q, &#39;mean&#39;, params[q][&#39;mean&#39;].mean(axis=1))
                self.set_param(q, &#39;variance&#39;, params[q][&#39;scale&#39;].mean(axis=1) * 2)
        else:
            raise Exception(&#34;possible methods of estimation are either &#39;BNSE&#39; or &#39;SM&#39;&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mogptk.csm.CSM"><code class="flex name class">
<span>class <span class="ident">CSM</span></span>
<span>(</span><span>dataset, Q=1, Rq=1, name='CSM', likelihood=None, variational=False, sparse=False, like_params={})</span>
</code></dt>
<dd>
<section class="desc"><p>Cross Spectral Mixture kernel [1] with Q components and Rq latent functions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dataset</code></strong> :&ensp;<a title="mogptk.dataset.DataSet" href="dataset.html#mogptk.dataset.DataSet"><code>DataSet</code></a></dt>
<dd>DataSet object of data for all channels.</dd>
<dt><strong><code>Q</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of components.</dd>
<dt><strong><code>Rq</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Sub components por components.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the model.</dd>
<dt><strong><code>likelihood</code></strong> :&ensp;<code>gpflow.likelihoods</code>, optional</dt>
<dd>Likelihood to use from GPFlow, if None a default exact inference Gaussian likelihood is used.</dd>
<dt><strong><code>variational</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, use variational inference to approximate function values as Gaussian. If False it will use Monte Carlo Markov Chain.</dd>
<dt><strong><code>sparse</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, will use sparse GP regression.</dd>
<dt><strong><code>like_params</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Parameters to GPflow likelihood.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; t = np.linspace(0, 10, 100)
&gt;&gt;&gt; y1 = np.sin(0.5 * t)
&gt;&gt;&gt; y2 = 2 * np.sin(0.2 * t)
&gt;&gt;&gt; import mogptk
&gt;&gt;&gt; data_list = []
&gt;&gt;&gt; mogptk.data_list.append(mogptk.Data(t, y1))
&gt;&gt;&gt; mogptk.data_list.append(mogptk.Data(t, y2))
&gt;&gt;&gt; model = mogptk.CSM(data_list, Q=2)
&gt;&gt;&gt; model.build()
&gt;&gt;&gt; model.train()
&gt;&gt;&gt; model.plot_prediction()
[1] K.R. Ulrich et al, "GP Kernels for Cross-Spectrum Analysis", Advances in Neural Information Processing Systems 28, 2015
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class CSM(model):
    &#34;&#34;&#34;
    Cross Spectral Mixture kernel [1] with Q components and Rq latent functions.

    Args:
        dataset (mogptk.dataset.DataSet): DataSet object of data for all channels.
        Q (int, optional): Number of components.
        Rq (int, optional): Sub components por components.
        name (str, optional): Name of the model.
        likelihood (gpflow.likelihoods, optional): Likelihood to use from GPFlow, if None a default exact inference Gaussian likelihood is used.
        variational (bool, optional): If True, use variational inference to approximate function values as Gaussian. If False it will use Monte Carlo Markov Chain.
        sparse (bool, optional): If True, will use sparse GP regression.
        like_params (dict, optional): Parameters to GPflow likelihood.

    Examples:
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; t = np.linspace(0, 10, 100)
        &gt;&gt;&gt; y1 = np.sin(0.5 * t)
        &gt;&gt;&gt; y2 = 2 * np.sin(0.2 * t)
        &gt;&gt;&gt; import mogptk
        &gt;&gt;&gt; data_list = []
        &gt;&gt;&gt; mogptk.data_list.append(mogptk.Data(t, y1))
        &gt;&gt;&gt; mogptk.data_list.append(mogptk.Data(t, y2))
        &gt;&gt;&gt; model = mogptk.CSM(data_list, Q=2)
        &gt;&gt;&gt; model.build()
        &gt;&gt;&gt; model.train()
        &gt;&gt;&gt; model.plot_prediction()

    [1] K.R. Ulrich et al, &#34;GP Kernels for Cross-Spectrum Analysis&#34;, Advances in Neural Information Processing Systems 28, 2015
    &#34;&#34;&#34;
    def __init__(self, dataset, Q=1, Rq=1, name=&#34;CSM&#34;, likelihood=None, variational=False, sparse=False, like_params={}):
        if Rq != 1:
            raise Exception(&#34;Rq != 1 is not (yet) supported&#34;) # TODO: support

        model.__init__(self, name, dataset)
        self.Q = Q
        self.Rq = Rq

        with self.graph.as_default():
            with self.session.as_default():
                for q in range(self.Q):
                    kernel = CrossSpectralMixture(
                        self.dataset.get_input_dims()[0],
                        self.dataset.get_output_dims(),
                        self.Rq,
                    )
                    if q == 0:
                        kernel_set = kernel
                    else:
                        kernel_set += kernel
                kernel_set += Noise(self.dataset.get_input_dims()[0], self.dataset.get_output_dims())
                self._build(kernel_set, likelihood, variational, sparse, like_params)
    
    def estimate_params(self, method=&#39;BNSE&#39;, sm_method=&#39;BNSE&#39;, sm_opt=&#39;BFGS&#39;, sm_maxiter=3000, plot=False):
        &#34;&#34;&#34;
        Estimate kernel parameters.

        The initialization can be done in two ways, the first by estimating the PSD via 
        BNSE (Tobar 2018) and then selecting the greater Q peaks in the estimated spectrum,
        the peaks position, magnitude and width initialize the mean, magnitude and variance
        of the kernel respectively.
        The second way is by fitting independent Gaussian process for each channel, each one
        with SM kernel, using the fitted parameters for initial values of the multioutput kernel.

        In all cases the noise is initialized with 1/30 of the variance 
        of each channel.

        Args:
            method (str, optional): Method of estimation, possible values are &#39;BNSE&#39; and &#39;SM&#39;.
            sm_method (str, optional): Method of estimating SM kernels. Only valid in &#39;SM&#39; mode.
            sm_opt (str, optional): Optimization method for SM kernels. Only valid in &#39;SM&#39; mode.
            sm_maxiter (str, optional): Maximum iteration for SM kernels. Only valid in &#39;SM&#39; mode.
            plot (bool, optional): Show the PSD of the kernel after fitting SM kernels. Only valid in &#39;SM&#39; mode.
        &#34;&#34;&#34;

        if method == &#39;BNSE&#39;:
            amplitudes, means, variances = self.dataset.get_bnse_estimation(self.Q)
            for q in range(self.Q):
                constant = np.empty((self.dataset.get_input_dims()[0], self.dataset.get_output_dims()))
                for channel in range(len(self.dataset)):
                    constant[:,channel] = amplitudes[channel][:,q].mean()
            
                constant = constant / constant.max()
                mean = np.array(means)[:,:,q].mean(axis=0)
                variance = np.array(variances)[:,:,q].mean(axis=0)

                self.set_param(q, &#39;constant&#39;, constant)
                self.set_param(q, &#39;mean&#39;, mean * 2 * np.pi)
                self.set_param(q, &#39;variance&#39;, variance * 5)
        elif method == &#39;SM&#39;:
            params = _estimate_from_sm(self.dataset, self.Q, method=sm_method, optimizer=sm_opt, maxiter=sm_maxiter, plot=plot)
            for q in range(self.Q):
                self.set_param(q, &#39;constant&#39;, params[q][&#39;weight&#39;].mean(axis=0).reshape(self.Rq, -1))
                self.set_param(q, &#39;mean&#39;, params[q][&#39;mean&#39;].mean(axis=1))
                self.set_param(q, &#39;variance&#39;, params[q][&#39;scale&#39;].mean(axis=1) * 2)
        else:
            raise Exception(&#34;possible methods of estimation are either &#39;BNSE&#39; or &#39;SM&#39;&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mogptk.model.model" href="model.html#mogptk.model.model">model</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mogptk.csm.CSM.estimate_params"><code class="name flex">
<span>def <span class="ident">estimate_params</span></span>(<span>self, method='BNSE', sm_method='BNSE', sm_opt='BFGS', sm_maxiter=3000, plot=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Estimate kernel parameters.</p>
<p>The initialization can be done in two ways, the first by estimating the PSD via
BNSE (Tobar 2018) and then selecting the greater Q peaks in the estimated spectrum,
the peaks position, magnitude and width initialize the mean, magnitude and variance
of the kernel respectively.
The second way is by fitting independent Gaussian process for each channel, each one
with SM kernel, using the fitted parameters for initial values of the multioutput kernel.</p>
<p>In all cases the noise is initialized with 1/30 of the variance
of each channel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Method of estimation, possible values are 'BNSE' and 'SM'.</dd>
<dt><strong><code>sm_method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Method of estimating SM kernels. Only valid in 'SM' mode.</dd>
<dt><strong><code>sm_opt</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Optimization method for SM kernels. Only valid in 'SM' mode.</dd>
<dt><strong><code>sm_maxiter</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Maximum iteration for SM kernels. Only valid in 'SM' mode.</dd>
<dt><strong><code>plot</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Show the PSD of the kernel after fitting SM kernels. Only valid in 'SM' mode.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def estimate_params(self, method=&#39;BNSE&#39;, sm_method=&#39;BNSE&#39;, sm_opt=&#39;BFGS&#39;, sm_maxiter=3000, plot=False):
    &#34;&#34;&#34;
    Estimate kernel parameters.

    The initialization can be done in two ways, the first by estimating the PSD via 
    BNSE (Tobar 2018) and then selecting the greater Q peaks in the estimated spectrum,
    the peaks position, magnitude and width initialize the mean, magnitude and variance
    of the kernel respectively.
    The second way is by fitting independent Gaussian process for each channel, each one
    with SM kernel, using the fitted parameters for initial values of the multioutput kernel.

    In all cases the noise is initialized with 1/30 of the variance 
    of each channel.

    Args:
        method (str, optional): Method of estimation, possible values are &#39;BNSE&#39; and &#39;SM&#39;.
        sm_method (str, optional): Method of estimating SM kernels. Only valid in &#39;SM&#39; mode.
        sm_opt (str, optional): Optimization method for SM kernels. Only valid in &#39;SM&#39; mode.
        sm_maxiter (str, optional): Maximum iteration for SM kernels. Only valid in &#39;SM&#39; mode.
        plot (bool, optional): Show the PSD of the kernel after fitting SM kernels. Only valid in &#39;SM&#39; mode.
    &#34;&#34;&#34;

    if method == &#39;BNSE&#39;:
        amplitudes, means, variances = self.dataset.get_bnse_estimation(self.Q)
        for q in range(self.Q):
            constant = np.empty((self.dataset.get_input_dims()[0], self.dataset.get_output_dims()))
            for channel in range(len(self.dataset)):
                constant[:,channel] = amplitudes[channel][:,q].mean()
        
            constant = constant / constant.max()
            mean = np.array(means)[:,:,q].mean(axis=0)
            variance = np.array(variances)[:,:,q].mean(axis=0)

            self.set_param(q, &#39;constant&#39;, constant)
            self.set_param(q, &#39;mean&#39;, mean * 2 * np.pi)
            self.set_param(q, &#39;variance&#39;, variance * 5)
    elif method == &#39;SM&#39;:
        params = _estimate_from_sm(self.dataset, self.Q, method=sm_method, optimizer=sm_opt, maxiter=sm_maxiter, plot=plot)
        for q in range(self.Q):
            self.set_param(q, &#39;constant&#39;, params[q][&#39;weight&#39;].mean(axis=0).reshape(self.Rq, -1))
            self.set_param(q, &#39;mean&#39;, params[q][&#39;mean&#39;].mean(axis=1))
            self.set_param(q, &#39;variance&#39;, params[q][&#39;scale&#39;].mean(axis=1) * 2)
    else:
        raise Exception(&#34;possible methods of estimation are either &#39;BNSE&#39; or &#39;SM&#39;&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mogptk.model.model" href="model.html#mogptk.model.model">model</a></b></code>:
<ul class="hlist">
<li><code><a title="mogptk.model.model.fix_param" href="model.html#mogptk.model.model.fix_param">fix_param</a></code></li>
<li><code><a title="mogptk.model.model.get_likelihood_params" href="model.html#mogptk.model.model.get_likelihood_params">get_likelihood_params</a></code></li>
<li><code><a title="mogptk.model.model.get_param" href="model.html#mogptk.model.model.get_param">get_param</a></code></li>
<li><code><a title="mogptk.model.model.get_params" href="model.html#mogptk.model.model.get_params">get_params</a></code></li>
<li><code><a title="mogptk.model.model.load_params" href="model.html#mogptk.model.model.load_params">load_params</a></code></li>
<li><code><a title="mogptk.model.model.plot_prediction" href="model.html#mogptk.model.model.plot_prediction">plot_prediction</a></code></li>
<li><code><a title="mogptk.model.model.predict" href="model.html#mogptk.model.model.predict">predict</a></code></li>
<li><code><a title="mogptk.model.model.print_params" href="model.html#mogptk.model.model.print_params">print_params</a></code></li>
<li><code><a title="mogptk.model.model.save_params" href="model.html#mogptk.model.model.save_params">save_params</a></code></li>
<li><code><a title="mogptk.model.model.set_likelihood_param" href="model.html#mogptk.model.model.set_likelihood_param">set_likelihood_param</a></code></li>
<li><code><a title="mogptk.model.model.set_param" href="model.html#mogptk.model.model.set_param">set_param</a></code></li>
<li><code><a title="mogptk.model.model.train" href="model.html#mogptk.model.model.train">train</a></code></li>
<li><code><a title="mogptk.model.model.unfix_param" href="model.html#mogptk.model.model.unfix_param">unfix_param</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mogptk" href="index.html">mogptk</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mogptk.csm.CSM" href="#mogptk.csm.CSM">CSM</a></code></h4>
<ul class="">
<li><code><a title="mogptk.csm.CSM.estimate_params" href="#mogptk.csm.CSM.estimate_params">estimate_params</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>